[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "portalocker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "portalocker",
        "description": "portalocker",
        "detail": "portalocker",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "aiosmtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiosmtplib",
        "description": "aiosmtplib",
        "detail": "aiosmtplib",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Tk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "aiofiles",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiofiles",
        "description": "aiofiles",
        "detail": "aiofiles",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "aiofiles.os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiofiles.os",
        "description": "aiofiles.os",
        "detail": "aiofiles.os",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "AsyncMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nadoo_connect",
        "description": "nadoo_connect",
        "isExtraImport": true,
        "detail": "nadoo_connect",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline_to_binary",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "manpage",
        "importPath": "docutils.writers",
        "description": "docutils.writers",
        "isExtraImport": true,
        "detail": "docutils.writers",
        "documentation": {}
    },
    {
        "label": "Writer",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "Reader",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "prepstyles",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "get_config_from_env_or_prompt",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def get_config_from_env_or_prompt():\n    required_vars = [\n        \"SMTP_SERVER\",\n        \"SMTP_PORT\",\n        \"EMAIL\",\n        \"PASSWORD\",\n        \"DESTINATION_EMAIL\",\n    ]\n    config = {var: os.getenv(var) for var in required_vars}\n    missing_configs = {var for var in required_vars if not config[var]}",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "request_missing_config",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def request_missing_config(missing_configs):\n    root = Tk()\n    root.withdraw()\n    config_updates = {}\n    for var in missing_configs:\n        config_updates[var] = simpledialog.askstring(\n            \"Configuration\", f\"Enter your {var.lower()}:\"\n        )\n    root.destroy()\n    return config_updates",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "save_missing_config_to_env",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def save_missing_config_to_env(config):\n    with open(\".env\", \"a\") as env_file:\n        for var, value in config.items():\n            if value is not None:\n                env_file.write(f\"{var}={value}\\n\")\nasync def send_async_email(\n    subject, message, to_email, smtp_server, smtp_port, email, password\n) -> bool:\n    try:\n        print_all_stack_traces",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "record_execution_in_db",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def record_execution_in_db(execution_uuid, customer_program_uuid, is_sent):\n    conn = sqlite3.connect(\"executions.db\")\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"CREATE TABLE IF NOT EXISTS execution_records \n           (execution_uuid TEXT, customer_program_uuid TEXT, is_sent BOOLEAN)\"\"\"\n    )\n    cursor.execute(\n        \"INSERT INTO execution_records VALUES (?, ?, ?)\",\n        (execution_uuid, customer_program_uuid, is_sent),",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "inject_config",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def inject_config(async_func):\n    async def wrapper(*args, **kwargs):\n        if \"config\" not in kwargs or kwargs[\"config\"] is None:\n            kwargs[\"config\"] = await load_or_request_config()\n        return await async_func(*args, **kwargs)\n    return wrapper\n@inject_config\nasync def create_execution(customer_program_uuid, config=None):\n    await setup_directories_async()\n    execution_data = get_execution_data(customer_program_uuid)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "get_execution_data",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def get_execution_data(customer_program_uuid):\n    execution_uuid = str(uuid.uuid4())\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n    return {\n        \"execution_uuid\": execution_uuid,\n        \"customer_program_uuid\": customer_program_uuid,\n        \"timestamp\": timestamp,\n    }\ndef save_execution_data(execution_data):\n    filepath = os.path.join(executions_dir, f\"{execution_data['execution_uuid']}.json\")",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "save_execution_data",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def save_execution_data(execution_data):\n    filepath = os.path.join(executions_dir, f\"{execution_data['execution_uuid']}.json\")\n    with open(filepath, \"w\") as file:\n        json.dump(execution_data, file)\ndef start_sender_loop_if_not_running(config):\n    global sender_process\n    try:\n        logger.debug(\"Attempting to acquire lock before starting process...\")\n        with portalocker.Lock(lockfile_path, mode=\"w\", timeout=5):  # Increased timeout\n            if sender_process is not None and sender_process.is_alive():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "start_sender_loop_if_not_running",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def start_sender_loop_if_not_running(config):\n    global sender_process\n    try:\n        logger.debug(\"Attempting to acquire lock before starting process...\")\n        with portalocker.Lock(lockfile_path, mode=\"w\", timeout=5):  # Increased timeout\n            if sender_process is not None and sender_process.is_alive():\n                logger.warning(\"A sender loop process is already running.\")\n                return\n            logger.debug(\"Lock acquired. Starting sender loop process.\")\n            sender_process = Process(target=run_sender_loop_process, args=(config,))",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "run_sender_loop_process",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def run_sender_loop_process(config):\n    try:\n        logger.debug(\"Process started, reacquiring lock...\")\n        with portalocker.Lock(lockfile_path, mode=\"w\", timeout=5):  # Consistent timeout\n            logger.debug(\"Lock reacquired by process. Running sender loop.\")\n            asyncio.run(sender_loop(config))\n    except portalocker.exceptions.LockException:\n        logger.warning(\"Unable to reacquire lock in process, exiting.\")\n    finally:\n        logger.debug(\"Sender loop process ending, releasing lock.\")",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "calculate_size",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def calculate_size(data):\n    return len(json.dumps(data))  # Returns the size of the data in bytes\nasync def main():\n    customer_program_uuid = \"specific-uuid-from-database\"\n    for i in range(20):\n        await create_execution(customer_program_uuid)\nif __name__ == \"__main__\":\n    asyncio.run(main(), debug=True)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Updated directory names\nstaged_dir = \"rpc_staged\"\nawaiting_response_dir = \"rpc_awaiting_response\"\ndone_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "staged_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "staged_dir = \"rpc_staged\"\nawaiting_response_dir = \"rpc_awaiting_response\"\ndone_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "awaiting_response_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "awaiting_response_dir = \"rpc_awaiting_response\"\ndone_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "done_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "done_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "executions_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "executions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "lockfile_path",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "lockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "idle_time",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "idle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "max_wait_time",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "max_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():\n    load_dotenv()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "email_size_limit",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "email_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "sender_process",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "sender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_setup_directories",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_setup_directories():\n    # Ensure the directory is removed before the test, for a clean state\n    if os.path.exists(executions_dir):\n        os.rmdir(executions_dir)\n    setup_directories_async()\n    assert os.path.exists(executions_dir)\n@pytest.mark.asyncio\nasync def test_send_async_email():\n    with patch(\"aiosmtplib.SMTP\", new_callable=AsyncMock) as mock_smtp:\n        result = await send_async_email(",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_record_execution_in_db",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_record_execution_in_db():\n    # Optionally, use an in-memory database for testing\n    # conn = sqlite3.connect(\":memory:\")\n    # cursor = conn.cursor()\n    # Replace the connection line in the record_execution_in_db function with\n    # cursor.execute(\"...\") and pass the cursor instead of opening a new connection.\n    record_execution_in_db(\"uuid\", \"program_uuid\", True)\n    conn = sqlite3.connect(\n        \"executions.db\"\n    )  # Consider using an in-memory database for testing",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_create_execution",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_create_execution():\n    # Setup before test\n    setup_directories_async()\n    create_execution(\"program_uuid\")\n    # Test\n    files = os.listdir(executions_dir)\n    assert len(files) > 0\n    with open(os.path.join(executions_dir, files[0]), \"r\") as file:\n        data = json.load(file)\n        assert \"execution_uuid\" in data",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "executions_dir",
        "kind": 5,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "executions_dir = (\n    \"executions\"  # Ensure this matches with your main script's directory name\n)\n@pytest.mark.asyncio\ndef test_setup_directories():\n    # Ensure the directory is removed before the test, for a clean state\n    if os.path.exists(executions_dir):\n        os.rmdir(executions_dir)\n    setup_directories_async()\n    assert os.path.exists(executions_dir)",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html",
        "description": "venv.bin.rst2html",
        "peekOfCode": "description = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\npublish_cmdline(writer_name='html', description=description)",
        "detail": "venv.bin.rst2html",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html4",
        "description": "venv.bin.rst2html4",
        "peekOfCode": "description = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\npublish_cmdline(writer_name='html4', description=description)",
        "detail": "venv.bin.rst2html4",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html5",
        "description": "venv.bin.rst2html5",
        "peekOfCode": "description = ('Generates HTML5 documents from standalone '\n               'reStructuredText sources.\\n'\n               + default_description)\npublish_cmdline(writer_name='html5', description=description)",
        "detail": "venv.bin.rst2html5",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2latex",
        "description": "venv.bin.rst2latex",
        "peekOfCode": "description = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources. '\n               'Reads from <source> (default is stdin) and writes to '\n               '<destination> (default is stdout).  See '\n               '<https://docutils.sourceforge.io/docs/user/latex.html> for '\n               'the full reference.')\npublish_cmdline(writer_name='latex', description=description)",
        "detail": "venv.bin.rst2latex",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2man",
        "description": "venv.bin.rst2man",
        "peekOfCode": "description = (\"Generates plain unix manual documents.  \"\n               + default_description)\npublish_cmdline(writer=manpage.Writer(), description=description)",
        "detail": "venv.bin.rst2man",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "description = ('Generates OpenDocument/OpenOffice/ODF documents from '\n               'standalone reStructuredText sources.  ' + default_description)\nwriter = Writer()\nreader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "writer",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "writer = Writer()\nreader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "reader",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "reader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "output = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2pseudoxml",
        "description": "venv.bin.rst2pseudoxml",
        "peekOfCode": "description = ('Generates pseudo-XML from standalone reStructuredText '\n               'sources (for testing purposes).  ' + default_description)\npublish_cmdline(description=description)",
        "detail": "venv.bin.rst2pseudoxml",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2s5",
        "description": "venv.bin.rst2s5",
        "peekOfCode": "description = ('Generates S5 (X)HTML slideshow documents from standalone '\n               'reStructuredText sources.  ' + default_description)\npublish_cmdline(writer_name='s5', description=description)",
        "detail": "venv.bin.rst2s5",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2xetex",
        "description": "venv.bin.rst2xetex",
        "peekOfCode": "description = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources for compilation with the Unicode-aware TeX variants '\n               'XeLaTeX or LuaLaTeX. '\n               'Reads from <source> (default is stdin) and writes to '\n               '<destination> (default is stdout).  See '\n               '<https://docutils.sourceforge.io/docs/user/latex.html> for '\n               'the full reference.')\npublish_cmdline(writer_name='xetex', description=description)",
        "detail": "venv.bin.rst2xetex",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2xml",
        "description": "venv.bin.rst2xml",
        "peekOfCode": "description = ('Generates Docutils-native XML from standalone '\n               'reStructuredText sources.  ' + default_description)\npublish_cmdline(writer_name='xml', description=description)",
        "detail": "venv.bin.rst2xml",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rstpep2html",
        "description": "venv.bin.rstpep2html",
        "peekOfCode": "description = ('Generates (X)HTML from reStructuredText-format PEP files.  '\n               + default_description)\npublish_cmdline(reader_name='pep', writer_name='pep_html',\n                description=description)",
        "detail": "venv.bin.rstpep2html",
        "documentation": {}
    }
]