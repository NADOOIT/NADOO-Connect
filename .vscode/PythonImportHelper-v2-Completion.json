[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "portalocker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "portalocker",
        "description": "portalocker",
        "detail": "portalocker",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "aiosmtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiosmtplib",
        "description": "aiosmtplib",
        "detail": "aiosmtplib",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Tk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "AsyncMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nadoo_connect",
        "description": "nadoo_connect",
        "isExtraImport": true,
        "detail": "nadoo_connect",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline_to_binary",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "manpage",
        "importPath": "docutils.writers",
        "description": "docutils.writers",
        "isExtraImport": true,
        "detail": "docutils.writers",
        "documentation": {}
    },
    {
        "label": "Writer",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "Reader",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "prepstyles",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup_directories",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)\n    return config\ndef get_config_from_env_or_prompt():\n    required_vars = [",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "load_or_request_config",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)\n    return config\ndef get_config_from_env_or_prompt():\n    required_vars = [\n        \"SMTP_SERVER\",\n        \"SMTP_PORT\",\n        \"EMAIL\",",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "get_config_from_env_or_prompt",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def get_config_from_env_or_prompt():\n    required_vars = [\n        \"SMTP_SERVER\",\n        \"SMTP_PORT\",\n        \"EMAIL\",\n        \"PASSWORD\",\n        \"DESTINATION_EMAIL\",\n    ]\n    config = {var: os.getenv(var) for var in required_vars}\n    missing_configs = {var for var in required_vars if not config[var]}",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "request_missing_config",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def request_missing_config(missing_configs):\n    root = Tk()\n    root.withdraw()\n    config_updates = {}\n    for var in missing_configs:\n        config_updates[var] = simpledialog.askstring(\n            \"Configuration\", f\"Enter your {var.lower()}:\"\n        )\n    root.destroy()\n    return config_updates",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "save_missing_config_to_env",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def save_missing_config_to_env(config):\n    with open(\".env\", \"a\") as env_file:\n        for var, value in config.items():\n            if value is not None:\n                env_file.write(f\"{var}={value}\\n\")\nasync def send_async_email(\n    subject, message, to_email, smtp_server, smtp_port, email, password\n):\n    try:\n        msg = MIMEText(message, _subtype=\"plain\", _charset=\"utf-8\")",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "record_execution_in_db",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def record_execution_in_db(execution_uuid, customer_program_uuid, is_sent):\n    conn = sqlite3.connect(\"executions.db\")\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"CREATE TABLE IF NOT EXISTS execution_records \n           (execution_uuid TEXT, customer_program_uuid TEXT, is_sent BOOLEAN)\"\"\"\n    )\n    cursor.execute(\n        \"INSERT INTO execution_records VALUES (?, ?, ?)\",\n        (execution_uuid, customer_program_uuid, is_sent),",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "create_execution",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def create_execution(customer_program_uuid):\n    global config, sender_task\n    if config is None:\n        config = load_or_request_config()\n    setup_directories()\n    execution_data = get_execution_data(customer_program_uuid)\n    save_execution_data(execution_data)\n    start_sender_loop_if_not_running()\ndef get_execution_data(customer_program_uuid):\n    execution_uuid = str(uuid.uuid4())",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "get_execution_data",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def get_execution_data(customer_program_uuid):\n    execution_uuid = str(uuid.uuid4())\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n    return {\n        \"execution_uuid\": execution_uuid,\n        \"customer_program_uuid\": customer_program_uuid,\n        \"timestamp\": timestamp,\n    }\ndef save_execution_data(execution_data):\n    filepath = os.path.join(executions_dir, f\"{execution_data['execution_uuid']}.json\")",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "save_execution_data",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def save_execution_data(execution_data):\n    filepath = os.path.join(executions_dir, f\"{execution_data['execution_uuid']}.json\")\n    with open(filepath, \"w\") as file:\n        json.dump(execution_data, file)\ndef start_sender_loop_if_not_running():\n    global sender_task\n    if sender_task is None or sender_task.done():\n        try:\n            with portalocker.Lock(lockfile_path, mode=\"w\", timeout=1):\n                try:",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "start_sender_loop_if_not_running",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def start_sender_loop_if_not_running():\n    global sender_task\n    if sender_task is None or sender_task.done():\n        try:\n            with portalocker.Lock(lockfile_path, mode=\"w\", timeout=1):\n                try:\n                    loop = asyncio.get_running_loop()\n                except RuntimeError:\n                    # Create a new event loop if there isn't a running one\n                    loop = asyncio.new_event_loop()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "calculate_size",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def calculate_size(data):\n    return len(json.dumps(data))  # Returns the size of the data in bytes\ndef main():\n    global config\n    config = load_or_request_config()\n    customer_program_uuid = \"specific-uuid-from-database\"\n    for i in range(100):\n        create_execution(customer_program_uuid)\nif __name__ == \"__main__\":\n    main()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def main():\n    global config\n    config = load_or_request_config()\n    customer_program_uuid = \"specific-uuid-from-database\"\n    for i in range(100):\n        create_execution(customer_program_uuid)\nif __name__ == \"__main__\":\n    main()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "executions_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "executions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nconfig = None\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nsender_task = None  # Global variable to keep track of the sender task\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "lockfile_path",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "lockfile_path = os.path.join(executions_dir, \"sender.lock\")\nconfig = None\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nsender_task = None  # Global variable to keep track of the sender task\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "config = None\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nsender_task = None  # Global variable to keep track of the sender task\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():\n    load_dotenv()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "idle_time",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "idle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nsender_task = None  # Global variable to keep track of the sender task\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "max_wait_time",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "max_wait_time = 120  # Maximum wait time in seconds between retries\nsender_task = None  # Global variable to keep track of the sender task\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "sender_task",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "sender_task = None  # Global variable to keep track of the sender task\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)\n    return config",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "email_size_limit",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "email_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\ndef setup_directories():\n    if not os.path.exists(executions_dir):\n        os.makedirs(executions_dir)\ndef load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)\n    return config\ndef get_config_from_env_or_prompt():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_setup_directories",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_setup_directories():\n    # Ensure the directory is removed before the test, for a clean state\n    if os.path.exists(executions_dir):\n        os.rmdir(executions_dir)\n    setup_directories()\n    assert os.path.exists(executions_dir)\n@pytest.mark.asyncio\nasync def test_send_async_email():\n    with patch(\"aiosmtplib.SMTP\", new_callable=AsyncMock) as mock_smtp:\n        result = await send_async_email(",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_record_execution_in_db",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_record_execution_in_db():\n    # Optionally, use an in-memory database for testing\n    # conn = sqlite3.connect(\":memory:\")\n    # cursor = conn.cursor()\n    # Replace the connection line in the record_execution_in_db function with\n    # cursor.execute(\"...\") and pass the cursor instead of opening a new connection.\n    record_execution_in_db(\"uuid\", \"program_uuid\", True)\n    conn = sqlite3.connect(\n        \"executions.db\"\n    )  # Consider using an in-memory database for testing",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_create_execution",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_create_execution():\n    # Setup before test\n    setup_directories()\n    create_execution(\"program_uuid\")\n    # Test\n    files = os.listdir(executions_dir)\n    assert len(files) > 0\n    with open(os.path.join(executions_dir, files[0]), \"r\") as file:\n        data = json.load(file)\n        assert \"execution_uuid\" in data",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "executions_dir",
        "kind": 5,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "executions_dir = (\n    \"executions\"  # Ensure this matches with your main script's directory name\n)\ndef test_setup_directories():\n    # Ensure the directory is removed before the test, for a clean state\n    if os.path.exists(executions_dir):\n        os.rmdir(executions_dir)\n    setup_directories()\n    assert os.path.exists(executions_dir)\n@pytest.mark.asyncio",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html",
        "description": "venv.bin.rst2html",
        "peekOfCode": "description = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\npublish_cmdline(writer_name='html', description=description)",
        "detail": "venv.bin.rst2html",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html4",
        "description": "venv.bin.rst2html4",
        "peekOfCode": "description = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\npublish_cmdline(writer_name='html4', description=description)",
        "detail": "venv.bin.rst2html4",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html5",
        "description": "venv.bin.rst2html5",
        "peekOfCode": "description = ('Generates HTML5 documents from standalone '\n               'reStructuredText sources.\\n'\n               + default_description)\npublish_cmdline(writer_name='html5', description=description)",
        "detail": "venv.bin.rst2html5",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2latex",
        "description": "venv.bin.rst2latex",
        "peekOfCode": "description = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources. '\n               'Reads from <source> (default is stdin) and writes to '\n               '<destination> (default is stdout).  See '\n               '<https://docutils.sourceforge.io/docs/user/latex.html> for '\n               'the full reference.')\npublish_cmdline(writer_name='latex', description=description)",
        "detail": "venv.bin.rst2latex",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2man",
        "description": "venv.bin.rst2man",
        "peekOfCode": "description = (\"Generates plain unix manual documents.  \"\n               + default_description)\npublish_cmdline(writer=manpage.Writer(), description=description)",
        "detail": "venv.bin.rst2man",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "description = ('Generates OpenDocument/OpenOffice/ODF documents from '\n               'standalone reStructuredText sources.  ' + default_description)\nwriter = Writer()\nreader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "writer",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "writer = Writer()\nreader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "reader",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "reader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "output = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2pseudoxml",
        "description": "venv.bin.rst2pseudoxml",
        "peekOfCode": "description = ('Generates pseudo-XML from standalone reStructuredText '\n               'sources (for testing purposes).  ' + default_description)\npublish_cmdline(description=description)",
        "detail": "venv.bin.rst2pseudoxml",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2s5",
        "description": "venv.bin.rst2s5",
        "peekOfCode": "description = ('Generates S5 (X)HTML slideshow documents from standalone '\n               'reStructuredText sources.  ' + default_description)\npublish_cmdline(writer_name='s5', description=description)",
        "detail": "venv.bin.rst2s5",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2xetex",
        "description": "venv.bin.rst2xetex",
        "peekOfCode": "description = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources for compilation with the Unicode-aware TeX variants '\n               'XeLaTeX or LuaLaTeX. '\n               'Reads from <source> (default is stdin) and writes to '\n               '<destination> (default is stdout).  See '\n               '<https://docutils.sourceforge.io/docs/user/latex.html> for '\n               'the full reference.')\npublish_cmdline(writer_name='xetex', description=description)",
        "detail": "venv.bin.rst2xetex",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2xml",
        "description": "venv.bin.rst2xml",
        "peekOfCode": "description = ('Generates Docutils-native XML from standalone '\n               'reStructuredText sources.  ' + default_description)\npublish_cmdline(writer_name='xml', description=description)",
        "detail": "venv.bin.rst2xml",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rstpep2html",
        "description": "venv.bin.rstpep2html",
        "peekOfCode": "description = ('Generates (X)HTML from reStructuredText-format PEP files.  '\n               + default_description)\npublish_cmdline(reader_name='pep', writer_name='pep_html',\n                description=description)",
        "detail": "venv.bin.rstpep2html",
        "documentation": {}
    }
]