[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "portalocker",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "portalocker",
        "description": "portalocker",
        "detail": "portalocker",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Tk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "simpledialog",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "aiofiles",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiofiles",
        "description": "aiofiles",
        "detail": "aiofiles",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "aiofiles.os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiofiles.os",
        "description": "aiofiles.os",
        "detail": "aiofiles.os",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nadoo_email",
        "description": "nadoo_email",
        "isExtraImport": true,
        "detail": "nadoo_email",
        "documentation": {}
    },
    {
        "label": "aiosmtplib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiosmtplib",
        "description": "aiosmtplib",
        "detail": "aiosmtplib",
        "documentation": {}
    },
    {
        "label": "MIMEText",
        "importPath": "email.mime.text",
        "description": "email.mime.text",
        "isExtraImport": true,
        "detail": "email.mime.text",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "aiosqlite",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiosqlite",
        "description": "aiosqlite",
        "detail": "aiosqlite",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Observer",
        "importPath": "watchdog.observers",
        "description": "watchdog.observers",
        "isExtraImport": true,
        "detail": "watchdog.observers",
        "documentation": {}
    },
    {
        "label": "FileSystemEventHandler",
        "importPath": "watchdog.events",
        "description": "watchdog.events",
        "isExtraImport": true,
        "detail": "watchdog.events",
        "documentation": {}
    },
    {
        "label": "send_email",
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "isExtraImport": true,
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "isExtraImport": true,
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "record_execution_in_db",
        "importPath": "nadoo_connect",
        "description": "nadoo_connect",
        "isExtraImport": true,
        "detail": "nadoo_connect",
        "documentation": {}
    },
    {
        "label": "load_or_request_config",
        "importPath": "nadoo_connect",
        "description": "nadoo_connect",
        "isExtraImport": true,
        "detail": "nadoo_connect",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "nadoo_connect",
        "description": "nadoo_connect",
        "isExtraImport": true,
        "detail": "nadoo_connect",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "AsyncMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "AsyncMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline_to_binary",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "publish_cmdline",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "default_description",
        "importPath": "docutils.core",
        "description": "docutils.core",
        "isExtraImport": true,
        "detail": "docutils.core",
        "documentation": {}
    },
    {
        "label": "locale",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "locale",
        "description": "locale",
        "detail": "locale",
        "documentation": {}
    },
    {
        "label": "manpage",
        "importPath": "docutils.writers",
        "description": "docutils.writers",
        "isExtraImport": true,
        "detail": "docutils.writers",
        "documentation": {}
    },
    {
        "label": "Writer",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "Reader",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "prepstyles",
        "importPath": "docutils.writers.odf_odt",
        "description": "docutils.writers.odf_odt",
        "isExtraImport": true,
        "detail": "docutils.writers.odf_odt",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "get_config_from_env_or_prompt",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def get_config_from_env_or_prompt():\n    required_vars = []  # Empty list for now\n    config = {var: os.getenv(var) for var in required_vars}\n    missing_configs = {var for var in required_vars if not config[var]}\n    if missing_configs:\n        config.update(request_missing_config(missing_configs))\n    return config\ndef request_missing_config(missing_configs):\n    root = Tk()\n    root.withdraw()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "request_missing_config",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def request_missing_config(missing_configs):\n    root = Tk()\n    root.withdraw()\n    config_updates = {}\n    for var in missing_configs:\n        config_updates[var] = simpledialog.askstring(\n            \"Configuration\", f\"Enter your {var.lower()}:\"\n        )\n    root.destroy()\n    return config_updates",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "save_missing_config_to_env",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def save_missing_config_to_env(config):\n    existing_config = {}\n    if os.path.exists(\".env\"):\n        with open(\".env\", \"r\") as env_file:\n            for line in env_file:\n                var, value = line.strip().split(\"=\", 1)\n                existing_config[var] = value\n    with open(\".env\", \"a\") as env_file:\n        for var, value in config.items():\n            if var not in existing_config or existing_config[var] != value:",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "record_execution_in_db",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def record_execution_in_db(execution_uuid, customer_program_uuid, is_sent):\n    conn = sqlite3.connect(\"executions.db\")\n    cursor = conn.cursor()\n    cursor.execute(\n        \"\"\"CREATE TABLE IF NOT EXISTS execution_records \n           (execution_uuid TEXT, customer_program_uuid TEXT, is_sent BOOLEAN)\"\"\"\n    )\n    cursor.execute(\n        \"INSERT INTO execution_records VALUES (?, ?, ?)\",\n        (execution_uuid, customer_program_uuid, is_sent),",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "inject_config",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def inject_config(async_func):\n    async def wrapper(*args, **kwargs):\n        if \"config\" not in kwargs or kwargs[\"config\"] is None:\n            kwargs[\"config\"] = await load_or_request_config()\n        return await async_func(*args, **kwargs)\n    return wrapper\n# TODO #7 remove config\n@inject_config\nasync def create_execution(customer_program_uuid, config=None):\n    await setup_directories_async()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "get_execution_data",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def get_execution_data(customer_program_uuid):\n    execution_uuid = str(uuid.uuid4())\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S.%f\")\n    return {\n        \"execution_uuid\": execution_uuid,\n        \"customer_program_uuid\": customer_program_uuid,\n        \"timestamp\": timestamp,\n    }\ndef save_execution_data(execution_data):\n    filepath = os.path.join(executions_dir, f\"{execution_data['execution_uuid']}.json\")",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "save_execution_data",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def save_execution_data(execution_data):\n    filepath = os.path.join(executions_dir, f\"{execution_data['execution_uuid']}.json\")\n    with open(filepath, \"w\") as file:\n        json.dump(execution_data, file)\ndef start_sender_loop_if_not_running(config):\n    global sender_process\n    try:\n        logger.debug(\"Attempting to acquire lock before starting process...\")\n        with portalocker.Lock(lockfile_path, mode=\"w\", timeout=5):  # Increased timeout\n            if sender_process is not None and sender_process.is_alive():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "start_sender_loop_if_not_running",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def start_sender_loop_if_not_running(config):\n    global sender_process\n    try:\n        logger.debug(\"Attempting to acquire lock before starting process...\")\n        with portalocker.Lock(lockfile_path, mode=\"w\", timeout=5):  # Increased timeout\n            if sender_process is not None and sender_process.is_alive():\n                logger.warning(\"A sender loop process is already running.\")\n                return\n            logger.debug(\"Lock acquired. Starting sender loop process.\")\n            sender_process = Process(target=run_sender_loop_process)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "run_sender_loop_process",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def run_sender_loop_process():\n    try:\n        logger.debug(\"Process started, reacquiring lock...\")\n        with portalocker.Lock(lockfile_path, mode=\"w\", timeout=5):  # Consistent timeout\n            logger.debug(\"Lock reacquired by process. Running sender loop.\")\n            asyncio.run(sender_loop())\n    except portalocker.exceptions.LockException:\n        logger.warning(\"Unable to reacquire lock in process, exiting.\")\n    finally:\n        logger.debug(\"Sender loop process ending, releasing lock.\")",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "calculate_size",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "def calculate_size(data):\n    return len(json.dumps(data))  # Returns the size of the data in bytes\nasync def main():\n    customer_program_uuid = \"specific-uuid-from-database\"\n    for i in range(10):\n        await create_execution(customer_program_uuid)\nif __name__ == \"__main__\":\n    asyncio.run(main(), debug=True)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "logs_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "logs_dir = \"logs\"\nif not os.path.exists(logs_dir):\n    os.makedirs(logs_dir)\n# Configure logging\nlog_file_path = os.path.join(logs_dir, \"nadoo_connect.log\")\nlogging.basicConfig(\n    level=logging.DEBUG,\n    filename=log_file_path,  # Path to log file in 'logs' directory\n    filemode=\"a\",  # 'a' means append\n    format=\"%(asctime)s - %(process)d - %(levelname)s - %(message)s\",  # Log format",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "log_file_path",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "log_file_path = os.path.join(logs_dir, \"nadoo_connect.log\")\nlogging.basicConfig(\n    level=logging.DEBUG,\n    filename=log_file_path,  # Path to log file in 'logs' directory\n    filemode=\"a\",  # 'a' means append\n    format=\"%(asctime)s - %(process)d - %(levelname)s - %(message)s\",  # Log format\n)\n# Assuming that the logger has been configured globally\nlogger = logging.getLogger(__name__)\n# Updated directory names",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# Updated directory names\nstaged_dir = \"rpc_staged\"\nawaiting_response_dir = \"rpc_awaiting_response\"\ndone_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "staged_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "staged_dir = \"rpc_staged\"\nawaiting_response_dir = \"rpc_awaiting_response\"\ndone_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "awaiting_response_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "awaiting_response_dir = \"rpc_awaiting_response\"\ndone_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "done_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "done_dir = \"rpc_done\"\nexecutions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "executions_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "executions_dir = \"executions\"\nlockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "lockfile_path",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "lockfile_path = os.path.join(executions_dir, \"sender.lock\")\nidle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "idle_time",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "idle_time = 120  # Idle time in seconds before shutting down the sender loop\nmax_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "max_wait_time",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "max_wait_time = 120  # Maximum wait time in seconds between retries\nemail_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():\n    load_dotenv()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "email_size_limit",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "email_size_limit = 72 * 1024  # Email size limit in bytes (72 KB)\nsender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "sender_process",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_connect",
        "description": "nadoo_connect.nadoo_connect",
        "peekOfCode": "sender_process = None  # To keep track of the sender process\nasync def print_all_stack_traces():\n    for task in asyncio.all_tasks():\n        task.print_stack()\n# Call this function at points where you want to inspect the state of all tasks\n# Remaining functions (load_or_request_config and get_config_from_env_or_prompt) will stay the same\nasync def load_or_request_config():\n    load_dotenv()\n    config = get_config_from_env_or_prompt()\n    save_missing_config_to_env(config)",
        "detail": "nadoo_connect.nadoo_connect",
        "documentation": {}
    },
    {
        "label": "log_errors",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def log_errors(func):\n    async def async_wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)\n        except Exception as e:\n            log_exception(func, args, kwargs, e)\n            raise\n    return async_wrapper\ndef log_exception(func, args, kwargs, e):\n    arg_values = \", \".join(",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "log_exception",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def log_exception(func, args, kwargs, e):\n    arg_values = \", \".join(\n        [repr(a) for a in args] + [f\"{k}={v!r}\" for k, v in kwargs.items()]\n    )\n    env_vars = {k: v for k, v in os.environ.items()}\n    error_logger.error(\n        f\"Exception in {func.__name__} with args [{arg_values}] and env vars [{env_vars}]: {e}\\n{traceback.format_exc()}\"\n    )\ndef get_execution_email_address():\n    # Hardcoded email address",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_execution_email_address",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_execution_email_address():\n    # Hardcoded email address\n    return \"executions@nadooit.de\"\ndef get_rpc_email_address():\n    # Hardcoded email address\n    return \"rpc@nadooit.de\"\ndef get_email_account_db_name() -> str:\n    return \"email_account.db\"\ndef email_account_db_name(func):\n    async def wrapper(*args, **kwargs):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_rpc_email_address",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_rpc_email_address():\n    # Hardcoded email address\n    return \"rpc@nadooit.de\"\ndef get_email_account_db_name() -> str:\n    return \"email_account.db\"\ndef email_account_db_name(func):\n    async def wrapper(*args, **kwargs):\n        if \"email_account_db_name\" not in kwargs:\n            kwargs[\"email_account_db_name\"] = get_email_account_db_name()\n        return await func(*args, **kwargs)",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_email_account_db_name",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_email_account_db_name() -> str:\n    return \"email_account.db\"\ndef email_account_db_name(func):\n    async def wrapper(*args, **kwargs):\n        if \"email_account_db_name\" not in kwargs:\n            kwargs[\"email_account_db_name\"] = get_email_account_db_name()\n        return await func(*args, **kwargs)\n    return wrapper\n# Async function to setup database\n@log_errors",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "email_account_db_name",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def email_account_db_name(func):\n    async def wrapper(*args, **kwargs):\n        if \"email_account_db_name\" not in kwargs:\n            kwargs[\"email_account_db_name\"] = get_email_account_db_name()\n        return await func(*args, **kwargs)\n    return wrapper\n# Async function to setup database\n@log_errors\n@email_account_db_name\nasync def setup_database(email_account_db_name: str):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_email_address_from_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_email_address_from_email_account(email_account):\n    return email_account[0]  # Email is the first element\n# Helper function to get POP3 server from email account details\ndef get_pop_server_from_email_account(email_account):\n    return email_account[1]  # POP3 server is the second element\n# Helper function to get POP3 port from email account details\ndef get_pop_port_from_email_account(email_account):\n    return email_account[2]  # POP3 port is the third element\n# Helper function to get SMTP server from email account details\ndef get_smtp_server_from_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_pop_server_from_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_pop_server_from_email_account(email_account):\n    return email_account[1]  # POP3 server is the second element\n# Helper function to get POP3 port from email account details\ndef get_pop_port_from_email_account(email_account):\n    return email_account[2]  # POP3 port is the third element\n# Helper function to get SMTP server from email account details\ndef get_smtp_server_from_email_account(email_account):\n    return email_account[3]  # SMTP server is the fourth element\n# Helper function to get SMTP port from email account details\ndef get_smtp_port_from_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_pop_port_from_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_pop_port_from_email_account(email_account):\n    return email_account[2]  # POP3 port is the third element\n# Helper function to get SMTP server from email account details\ndef get_smtp_server_from_email_account(email_account):\n    return email_account[3]  # SMTP server is the fourth element\n# Helper function to get SMTP port from email account details\ndef get_smtp_port_from_email_account(email_account):\n    return email_account[4]  # SMTP port is the fifth element\n# Helper function to get the password from email account details\ndef get_email_address_password_from_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_smtp_server_from_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_smtp_server_from_email_account(email_account):\n    return email_account[3]  # SMTP server is the fourth element\n# Helper function to get SMTP port from email account details\ndef get_smtp_port_from_email_account(email_account):\n    return email_account[4]  # SMTP port is the fifth element\n# Helper function to get the password from email account details\ndef get_email_address_password_from_email_account(email_account):\n    return email_account[5]  # Password is the sixth element\n# Helper function to check if POP3 server is present in email account details\ndef check_pop_server_in_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_smtp_port_from_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_smtp_port_from_email_account(email_account):\n    return email_account[4]  # SMTP port is the fifth element\n# Helper function to get the password from email account details\ndef get_email_address_password_from_email_account(email_account):\n    return email_account[5]  # Password is the sixth element\n# Helper function to check if POP3 server is present in email account details\ndef check_pop_server_in_email_account(email_account):\n    return get_pop_server_from_email_account(email_account) is not None\n# Helper function to check if POP3 port is present in email account details\ndef check_pop_port_in_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "get_email_address_password_from_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def get_email_address_password_from_email_account(email_account):\n    return email_account[5]  # Password is the sixth element\n# Helper function to check if POP3 server is present in email account details\ndef check_pop_server_in_email_account(email_account):\n    return get_pop_server_from_email_account(email_account) is not None\n# Helper function to check if POP3 port is present in email account details\ndef check_pop_port_in_email_account(email_account):\n    return get_pop_port_from_email_account(email_account) is not None\n# Helper function to check if SMTP server is present in email account details\ndef check_smtp_server_in_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "check_pop_server_in_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def check_pop_server_in_email_account(email_account):\n    return get_pop_server_from_email_account(email_account) is not None\n# Helper function to check if POP3 port is present in email account details\ndef check_pop_port_in_email_account(email_account):\n    return get_pop_port_from_email_account(email_account) is not None\n# Helper function to check if SMTP server is present in email account details\ndef check_smtp_server_in_email_account(email_account):\n    return get_smtp_server_from_email_account(email_account) is not None\n# Helper function to check if SMTP port is present in email account details\ndef check_smtp_port_in_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "check_pop_port_in_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def check_pop_port_in_email_account(email_account):\n    return get_pop_port_from_email_account(email_account) is not None\n# Helper function to check if SMTP server is present in email account details\ndef check_smtp_server_in_email_account(email_account):\n    return get_smtp_server_from_email_account(email_account) is not None\n# Helper function to check if SMTP port is present in email account details\ndef check_smtp_port_in_email_account(email_account):\n    return get_smtp_port_from_email_account(email_account) is not None\n# Helper function to check if the password is present in email account details\ndef check_password_in_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "check_smtp_server_in_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def check_smtp_server_in_email_account(email_account):\n    return get_smtp_server_from_email_account(email_account) is not None\n# Helper function to check if SMTP port is present in email account details\ndef check_smtp_port_in_email_account(email_account):\n    return get_smtp_port_from_email_account(email_account) is not None\n# Helper function to check if the password is present in email account details\ndef check_password_in_email_account(email_account):\n    return get_email_address_password_from_email_account(email_account) is not None\n# Async function to set default email address\n@log_errors",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "check_smtp_port_in_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def check_smtp_port_in_email_account(email_account):\n    return get_smtp_port_from_email_account(email_account) is not None\n# Helper function to check if the password is present in email account details\ndef check_password_in_email_account(email_account):\n    return get_email_address_password_from_email_account(email_account) is not None\n# Async function to set default email address\n@log_errors\n@email_account_db_name\nasync def set_default_email_address(email_address: str, email_account_db_name: str):\n    async with aiosqlite.connect(email_account_db_name) as conn:",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "check_password_in_email_account",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def check_password_in_email_account(email_account):\n    return get_email_address_password_from_email_account(email_account) is not None\n# Async function to set default email address\n@log_errors\n@email_account_db_name\nasync def set_default_email_address(email_address: str, email_account_db_name: str):\n    async with aiosqlite.connect(email_account_db_name) as conn:\n        await conn.execute(\"UPDATE email_accounts SET is_default = 0\")\n        await conn.execute(\n            \"UPDATE email_accounts SET is_default = 1 WHERE email = ?\", (email_address,)",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "is_valid_email",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "def is_valid_email(email):\n    pattern = r\"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$)\"\n    return re.match(pattern, email) is not None\n# Function to request missing email account details from user\nasync def get_email_account_from_user(email_address, email_account):\n    root = tk.Tk()\n    root.withdraw()  # Hide the main window\n    email_account = email_account.copy()  # Start with existing details\n    # Check and ask for missing POP server\n    if not check_pop_server_in_email_account(email_account):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "logs_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "logs_dir = \"logs\"\nif not os.path.exists(logs_dir):\n    os.makedirs(logs_dir)\n# Setup a dedicated error logger\nerror_logger = logging.getLogger(\"error_logger\")\nerror_logger.setLevel(logging.ERROR)\nerror_handler = logging.FileHandler(os.path.join(logs_dir, \"error_logs.log\"))\nerror_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n)",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "error_logger",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "error_logger = logging.getLogger(\"error_logger\")\nerror_logger.setLevel(logging.ERROR)\nerror_handler = logging.FileHandler(os.path.join(logs_dir, \"error_logs.log\"))\nerror_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n)\nerror_logger.addHandler(error_handler)\n# Decorator for enhanced error logging\ndef log_errors(func):\n    async def async_wrapper(*args, **kwargs):",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "error_handler",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_email",
        "description": "nadoo_connect.nadoo_email",
        "peekOfCode": "error_handler = logging.FileHandler(os.path.join(logs_dir, \"error_logs.log\"))\nerror_handler.setFormatter(\n    logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n)\nerror_logger.addHandler(error_handler)\n# Decorator for enhanced error logging\ndef log_errors(func):\n    async def async_wrapper(*args, **kwargs):\n        try:\n            return await func(*args, **kwargs)",
        "detail": "nadoo_connect.nadoo_email",
        "documentation": {}
    },
    {
        "label": "RPCEventHandler",
        "kind": 6,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "class RPCEventHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            rpc_file_queue.put(event.src_path)\n            logger.debug(f\"RPC file added to queue: {event.src_path}\")\nclass ExecutionEventHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            execution_file_queue.put(event.src_path)\n            logger.debug(f\"Execution file added to queue: {event.src_path}\")",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "ExecutionEventHandler",
        "kind": 6,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "class ExecutionEventHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            execution_file_queue.put(event.src_path)\n            logger.debug(f\"Execution file added to queue: {event.src_path}\")\nasync def process_rpc_files(config):\n    while not rpc_file_queue.empty():\n        file_path = rpc_file_queue.get()\n        # Process the file\n        # TODO: Implement the actual file processing logic here",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "setup_logger",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "def setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup as many loggers as you want\"\"\"\n    # Create 'logs' directory if it doesn't exist\n    logs_dir = \"logs\"\n    if not os.path.exists(logs_dir):\n        os.makedirs(logs_dir)\n    # Full path for log file\n    log_file_path = os.path.join(logs_dir, log_file)\n    # Create a logger\n    handler = logging.FileHandler(log_file_path)",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "clear_rpc_directory",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "def clear_rpc_directory():\n    for filename in os.listdir(staged_dir):\n        os.remove(os.path.join(staged_dir, filename))\ndef start_watchers():\n    rpc_event_handler = RPCEventHandler()\n    execution_event_handler = ExecutionEventHandler()\n    observer = Observer()\n    observer.schedule(rpc_event_handler, path=staged_dir, recursive=False)\n    observer.schedule(execution_event_handler, path=executions_dir, recursive=False)\n    observer.start()",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "start_watchers",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "def start_watchers():\n    rpc_event_handler = RPCEventHandler()\n    execution_event_handler = ExecutionEventHandler()\n    observer = Observer()\n    observer.schedule(rpc_event_handler, path=staged_dir, recursive=False)\n    observer.schedule(execution_event_handler, path=executions_dir, recursive=False)\n    observer.start()\n    return observer\ndef queue_existing_execution_files():\n    for filename in os.listdir(executions_dir):",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "queue_existing_execution_files",
        "kind": 2,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "def queue_existing_execution_files():\n    for filename in os.listdir(executions_dir):\n        if filename.endswith(\".json\"):\n            file_path = os.path.join(executions_dir, filename)\n            execution_file_queue.put(file_path)\nasync def main():\n    clear_rpc_directory()\n    queue_existing_execution_files()  # Queue existing execution files\n    config = await load_or_request_config()\n    observer = start_watchers()",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "staged_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "staged_dir = \"rpc_staged\"\nexecutions_dir = \"executions\"\n# Global thread-safe queues\nrpc_file_queue = queue.Queue()\nexecution_file_queue = queue.Queue()\ndef setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup as many loggers as you want\"\"\"\n    # Create 'logs' directory if it doesn't exist\n    logs_dir = \"logs\"\n    if not os.path.exists(logs_dir):",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "executions_dir",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "executions_dir = \"executions\"\n# Global thread-safe queues\nrpc_file_queue = queue.Queue()\nexecution_file_queue = queue.Queue()\ndef setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup as many loggers as you want\"\"\"\n    # Create 'logs' directory if it doesn't exist\n    logs_dir = \"logs\"\n    if not os.path.exists(logs_dir):\n        os.makedirs(logs_dir)",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "rpc_file_queue",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "rpc_file_queue = queue.Queue()\nexecution_file_queue = queue.Queue()\ndef setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup as many loggers as you want\"\"\"\n    # Create 'logs' directory if it doesn't exist\n    logs_dir = \"logs\"\n    if not os.path.exists(logs_dir):\n        os.makedirs(logs_dir)\n    # Full path for log file\n    log_file_path = os.path.join(logs_dir, log_file)",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "execution_file_queue",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "execution_file_queue = queue.Queue()\ndef setup_logger(name, log_file, level=logging.DEBUG):\n    \"\"\"Function to setup as many loggers as you want\"\"\"\n    # Create 'logs' directory if it doesn't exist\n    logs_dir = \"logs\"\n    if not os.path.exists(logs_dir):\n        os.makedirs(logs_dir)\n    # Full path for log file\n    log_file_path = os.path.join(logs_dir, log_file)\n    # Create a logger",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "nadoo_connect.nadoo_file_watcher_processor",
        "description": "nadoo_connect.nadoo_file_watcher_processor",
        "peekOfCode": "logger = setup_logger(\"file_watcher_processor_logger\", \"file_watcher_processor.log\")\nclass RPCEventHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            rpc_file_queue.put(event.src_path)\n            logger.debug(f\"RPC file added to queue: {event.src_path}\")\nclass ExecutionEventHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            execution_file_queue.put(event.src_path)",
        "detail": "nadoo_connect.nadoo_file_watcher_processor",
        "documentation": {}
    },
    {
        "label": "cleanup_specific_files_after_tests",
        "kind": 2,
        "importPath": "tests.test_email",
        "description": "tests.test_email",
        "peekOfCode": "def cleanup_specific_files_after_tests():\n    # Setup code (runs before any tests)\n    yield\n    # Cleanup code (runs after all tests)\n    pattern = \"<async_generator object setup_database_for_testing at *\"  # Define your file naming pattern\n    for filename in glob.glob(pattern):\n        try:\n            os.remove(filename)\n            print(f\"Deleted file: {filename}\")\n        except OSError as e:",
        "detail": "tests.test_email",
        "documentation": {}
    },
    {
        "label": "test_is_valid_email",
        "kind": 2,
        "importPath": "tests.test_email",
        "description": "tests.test_email",
        "peekOfCode": "def test_is_valid_email():\n    assert is_valid_email(\"test@example.com\") == True\n    assert is_valid_email(\"invalidemail\") == False\n@pytest.mark.asyncio\nasync def test_get_default_email_account(setup_database_for_testing):\n    test_db_name = setup_database_for_testing\n    # Your test code using test_db_name\n    # Set up an in-memory SQLite database\n    async with aiosqlite.connect(test_db_name) as conn:\n        # Create the email_accounts table and insert test data",
        "detail": "tests.test_email",
        "documentation": {}
    },
    {
        "label": "MockSMTP",
        "kind": 6,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "class MockSMTP:\n    def __init__(self, *args, **kwargs):\n        pass\n    async def __aenter__(self):\n        return self\n    async def __aexit__(self, exc_type, exc_value, traceback):\n        pass\n    async def login(self, *args, **kwargs):\n        pass\n    async def send_message(self, *args, **kwargs):",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "test_record_execution_in_db",
        "kind": 2,
        "importPath": "tests.test_nadoo_connect",
        "description": "tests.test_nadoo_connect",
        "peekOfCode": "def test_record_execution_in_db():\n    # Optionally, use an in-memory database for testing\n    # conn = sqlite3.connect(\":memory:\")\n    # cursor = conn.cursor()\n    # Replace the connection line in the record_execution_in_db function with\n    # cursor.execute(\"...\") and pass the cursor instead of opening a new connection.\n    record_execution_in_db(\"uuid\", \"program_uuid\", True)\n    conn = sqlite3.connect(\n        \"executions.db\"\n    )  # Consider using an in-memory database for testing",
        "detail": "tests.test_nadoo_connect",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html",
        "description": "venv.bin.rst2html",
        "peekOfCode": "description = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\npublish_cmdline(writer_name='html', description=description)",
        "detail": "venv.bin.rst2html",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html4",
        "description": "venv.bin.rst2html4",
        "peekOfCode": "description = ('Generates (X)HTML documents from standalone reStructuredText '\n               'sources.  ' + default_description)\npublish_cmdline(writer_name='html4', description=description)",
        "detail": "venv.bin.rst2html4",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2html5",
        "description": "venv.bin.rst2html5",
        "peekOfCode": "description = ('Generates HTML5 documents from standalone '\n               'reStructuredText sources.\\n'\n               + default_description)\npublish_cmdline(writer_name='html5', description=description)",
        "detail": "venv.bin.rst2html5",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2latex",
        "description": "venv.bin.rst2latex",
        "peekOfCode": "description = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources. '\n               'Reads from <source> (default is stdin) and writes to '\n               '<destination> (default is stdout).  See '\n               '<https://docutils.sourceforge.io/docs/user/latex.html> for '\n               'the full reference.')\npublish_cmdline(writer_name='latex', description=description)",
        "detail": "venv.bin.rst2latex",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2man",
        "description": "venv.bin.rst2man",
        "peekOfCode": "description = (\"Generates plain unix manual documents.  \"\n               + default_description)\npublish_cmdline(writer=manpage.Writer(), description=description)",
        "detail": "venv.bin.rst2man",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "description = ('Generates OpenDocument/OpenOffice/ODF documents from '\n               'standalone reStructuredText sources.  ' + default_description)\nwriter = Writer()\nreader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "writer",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "writer = Writer()\nreader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "reader",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "reader = Reader()\noutput = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "output",
        "kind": 5,
        "importPath": "venv.bin.rst2odt",
        "description": "venv.bin.rst2odt",
        "peekOfCode": "output = publish_cmdline_to_binary(reader=reader, writer=writer,\n                                   description=description)",
        "detail": "venv.bin.rst2odt",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2pseudoxml",
        "description": "venv.bin.rst2pseudoxml",
        "peekOfCode": "description = ('Generates pseudo-XML from standalone reStructuredText '\n               'sources (for testing purposes).  ' + default_description)\npublish_cmdline(description=description)",
        "detail": "venv.bin.rst2pseudoxml",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2s5",
        "description": "venv.bin.rst2s5",
        "peekOfCode": "description = ('Generates S5 (X)HTML slideshow documents from standalone '\n               'reStructuredText sources.  ' + default_description)\npublish_cmdline(writer_name='s5', description=description)",
        "detail": "venv.bin.rst2s5",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2xetex",
        "description": "venv.bin.rst2xetex",
        "peekOfCode": "description = ('Generates LaTeX documents from standalone reStructuredText '\n               'sources for compilation with the Unicode-aware TeX variants '\n               'XeLaTeX or LuaLaTeX. '\n               'Reads from <source> (default is stdin) and writes to '\n               '<destination> (default is stdout).  See '\n               '<https://docutils.sourceforge.io/docs/user/latex.html> for '\n               'the full reference.')\npublish_cmdline(writer_name='xetex', description=description)",
        "detail": "venv.bin.rst2xetex",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rst2xml",
        "description": "venv.bin.rst2xml",
        "peekOfCode": "description = ('Generates Docutils-native XML from standalone '\n               'reStructuredText sources.  ' + default_description)\npublish_cmdline(writer_name='xml', description=description)",
        "detail": "venv.bin.rst2xml",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "venv.bin.rstpep2html",
        "description": "venv.bin.rstpep2html",
        "peekOfCode": "description = ('Generates (X)HTML from reStructuredText-format PEP files.  '\n               + default_description)\npublish_cmdline(reader_name='pep', writer_name='pep_html',\n                description=description)",
        "detail": "venv.bin.rstpep2html",
        "documentation": {}
    }
]